---
title: "如何写好代码"
date: 2022-01-04T00:00:01+08:00
draft: false
tags: ["写好代码","入门"]
categories: ["学习笔记"]
---

> [如何写好代码](../dir)

## 函数

- 使用描述性的名称，不要担心名字太长
- 函数参数不要超过 2 个
- 如果函数需要 3 个或 3 个以上参数，说明期中一些参数应该封装成类
- 使用异常代替返回错误码，错误处理代码就能从住路径代码中分离出来
- 最好把 try 和 catch 代码块的主题部分抽离处理，另外形成函数，让丑陋的代码变得美丽
- 使用异常代替错误码，新异常就可以从异常类派生处理，无需编译或重新部署
- 不要重复自己
- 如何写出这样的函数：开始随意写 -> 单元测试覆盖每行代码 -> 分解函数、修改名称、消除重复 -> 保持测试通过 -> 优秀的函数

## 格式

- 一个文件尽量不超过 200~500 行
- 相关函数
  - 若某个函数调用了另外一个,就应该把它们放到一起,而且调用者应该尽可能放在被调用者上面
  - 这样，程序就有个自然的顺序
- 概念相关：概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短
- 一行代码不要超过 120 字符

## 对象和数据结构

> **对象**暴露行为，隐藏数据
> **数据结构**暴露数据，没有明显的行为

### 得墨忒耳定律（最少知识原则）

- 模块不应了解它所操作**对象**的内部情形
- 对象隐藏数据，暴露操作
- 对象不应该通过存取器（get/set）暴露其内部结构
- 得墨忒耳定律认为，类 C 的方法 f 只应该调用以下对象的方法
  - C
  - 由 f 创建的对象
  - 作为参数传递给 f 的对象
  - 由 C 的实体变量持有的对象
- 方法**不应该**调用由任何函数返回的对象的方法。（只跟朋友说话，不与陌生人谈话）

下列代码（出自 Apache 某项目）违反了得墨忒耳定律

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

这类代码常被称作**火车失事**，最好做类似如下的切分

```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

但上例依然违反了得墨忒耳定律

- 模块知道 ctxt 对象包含有多个选项
- 每个选项中都有一个临时目录
- 而每个临时目录都有一个绝对路径
- 对于一个函数，这些知识太多了
- 调用函数需要懂得如何在一大堆不同对象间浏览

这些代码是否违反得墨忒耳定律，取决于 ctxt、Options 和 ScratchDir 是对象还是数据结构

- 如果是对象，则他们的内部结构应当隐藏而不暴露，而不是暴露其内部细节，明显违反了得墨忒耳定律
- 如果 ctxt、Options 和 ScratchDir 只是数据结构，没有任何行为，本来就是暴露出来用于操作，所以不违反得墨忒耳定律

这样就不违反得墨忒耳定律

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

上面说了那么多，已经懵圈了，因为代码的最终目的是创建一个临时文件

```java
Srtring outFile = outputDir + "/" + className.replace('.', '/') + ".class";
FileOutputStream fout = new FileOutputStream(outFile);
BufferedOutputStream bos = new BufferedOutputStream(fout);
```

隐藏结构正确示例

```java
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

### 数据传送对象 DTO

> **DTO** (Data Transfer Object)
> 最为精炼的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象

DTO 是非常有用的结构，尤其在下列场景中

- 与数据库通信
- 解析套接字传递的消息

⚠️ 不幸

- 开发者经常往这里数据结构中塞进业务规则方法，把这类数据结构当成对象来用
- 这将导致数据结构和对象的混杂体

## 错误处理

### 使用异常而非返回码

### 使用不可控异常

可控异常时非必须的，以下语言都不支持

- C#
- C++
- Python
- Ruby

> 可控异常的代价是**违反开闭原则**

- 如果你在方法中抛出可控异常，而 catch 语句在三个层级之上，**你就得在 catch 语句和抛出异常处之间的每个方法签名中声明该异常**
- 这异味着对软件中较低层级的修改，都将波及较高层级的签名
- 修改好的模块必须重新构建、发布，就算它们自身所关注的任何东西都没改动过

### 给出异常发生的环境说明

- 你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所
- Java 中的异常堆栈踪迹无法告诉你该失败操作的初衷
- 应创建信息充分的错误消息，并和异常一起传递出去
- 在消息中，包括**失败的操作**和**失败类型**
- 如果你的应用程序有日志系统，传递足够的信息给 catch 块，并记录

### 依调用者需要定义异常类

- 按来源分类：来自组件或其他地方
- 按类型分类：设备错误、网络错误、编程错误
- 最重要是**考虑它们如何被捕获**
  - 例如封装第三方 API 异常
    - 好处是你不必绑死在蘑菇特定厂商的 API 设计上。可以定义自己喜欢的 API
    - 将无限可能缩小到有限范围

### 定义常规流程

下面的笨代码来自某个记账应用的总开支总计模块

```java
try {
  MealExpenses expense = expenseReportDao.getMeals(employee.getID());
  m_total += expenses.getTotal();
} cach(MealExpensesNotFound e) {
  m_total += getMealPerDime();
}
```

业务逻辑

- 如果消耗了餐食，则计入总额中
- 如果没有消耗，则员工得到当日餐食补贴
- **异常打断了业务逻辑**

让代码简洁

- 修改 ExpenseReportDao，使其总是返回 MealExpense 对象
- 如果没有餐食消耗，就返回一个餐食补贴的 MealExpense 对象

```java
MealExpenses expense = expenseReportDao.getMeals(employee.getID());
m_total += expense.getTotal();
```

这种手法叫做**特例模式**（Special case pattern）。创建一个类或配置一个对象，用来处理特例

- 你来处理特例，客户代码就不用应付异常行为了
- 异常行为被封装到特例对象中

### 别返回 null 值

### 别传递 null 值

- 相对好点的方式是使用断言效验入参
- 在大多数编程语言中，没有良好的方法能对付由调用者意外传入的 null 值