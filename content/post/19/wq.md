---
title: "「徐昊·TDD项目实战70讲」学习群笔记"
date: 2022-04-03T00:00:01+08:00
draft: false
tags: ["TDD","极客时间"]
categories: ["学习笔记"]
---

> [TDD 学习笔记 | 极客时间 | 徐昊·TDD 项目实战 70 讲](../dir)

本文内容主要来自[**徐昊**](https://www.thoughtworks.com/profiles/x/xu-hao-cn)老师和同学之间的互动讨论

## 徐昊

### Thoughtworks 中国区 CTO

> Thoughtworks全球技术策略顾问、中国区首席咨询师，同时也是北京Java用户组（BJUG： Beijing Java User Group）和Agile China创始人。他从2003年起开始实践极限编程等敏捷方法，2005年开始，多次以敏捷教练的角色帮助国内外多个团队实施极限编程。他在Scrum和FDD等敏捷方法、以及敏捷交付和敏捷项目管理等方面的经验极为丰富。目前，他主要致力于大规模团队（300-500人）内的敏捷实践和管理再造，以及对企业级技术应用趋势和技术战略的研究。

## 有哪些状态验证技术推荐吗？

- 做各种fake mountainbike,mock,in men do, test container
- 目的就是尽量少做行为验证
- **所谓测试策略 就是在保证有效性的同时 尽可能降低测试成本**
- 维持测试有效性 有个最小成本
- 小过这个 测试就无效了 或者不足以支撑长期演化（重构）
- 所以你没办法一直缩短测试时间
- 这也是我们讲的 始终使用状态验证 防止测试失效
- 在状态验证里 通过stub 偷换fake 降低成本

## AI + TDD 起飞

- 在 TDD 和结对编程里有一条规矩
  - 资深的写测试
  - 初级程序员写生产代码
- 在合理的单元构造**有效的测试**，实现就走不了样
- 现在配合 AI 编程
  - 程序员的主要任务就变成了验证 AI 写的代码符合要求
  - TDD 就是非常自然的做法：写测试，触发 AI 通过测试
- pair 里写测试的人叫 poilt
- 测试需要维护
- 测试写的好坏直接决定代码质量
- 测试写不好的程序员，生产代码也写不好
  - 主要的思考活动，都在写那些测试
  - 大部分程序员效率不高在于想不清楚
  - 至于实现 相比之下 那是非常简单了

## 对测试代码的建议

- 保留额外的大粒度测试，是测试金字塔变形主要原因
- 从验证功能的角度讲 很容易就写成所有功能测试的集合 这样的测试集合 维护和运行成本都比较高
- 至于任务分解，前面有同学讲到了 因为一开始没有架构愿景，所以拆封的都是功能点。在重构之后，架构模块改变了，对应的测试策略也要改变

## 关于设计模式的建议

- [极客时间 | 如何落地业务建模 | 说点题外话02｜模式并不是解决方案](http://gk.link/a/11irF)
  - 模式与建模是一样的，都是**问题先行**
  - 模式**最难的地方就在于判断当前的问题与模式要解决的是否是同一个问题**，这也是为什么我们提倡通过重构获得模式
    - 当问题明显出现的时候（以坏味道的形式），那么最难的一步其实你已经解决了
    - 这时再通过重构去得到具体的解决方案，反而是简单的
- [极客时间 | 软件设计之美 | 25 | 设计模式：每一种都是一个特定问题的解决方案](http://gk.link/a/11irM)
  - 学习设计模式不仅仅要学习代码怎么写，更重要的是要了解模式的应用场景
  - 设计原则其实是这些模式背后的东西
  - 设计模式只是设计原则在特定场景下的应用

## 关于伦敦学派用测试替身，有几个问题

### 问

- 被替身的组件本身的行为如何测试？
- 如果他们返回的数据并不像stub假设的一样怎么办？
- 如果把ArgTest里面所有用到OptionClass的stub，也照搬一份到OptionClass的测试里面当做测试用例，算不算一种重复？

### 答

- 伦敦学派的前提 就是交互确定
- 然后沿着调用栈依次实现
- 如果被stub组件行为和stub行为不同
- 那就是前提不成了
- 不成立
- 所以你的问题相当于 如果伦敦学派的前提不成立 怎么使用伦敦学派
- 答案是：用不了

## Intellij IDEA 的常用的快捷键视频

- [纯视频](https://space.bilibili.com/210253111/channel/seriesdetail?sid=1911259&ctype=0)
- [文字 + 视频链接](../../3/8)

## 任务分解是两层的：需求、架构/架构思想

- 架构不一定能达到一致
- 只能分解功能点，到不了任务
- 任务里有架构构想

## 图书收集

- 《Refactoring to Pattern》中文版《重构与模式》
- 《How Google Tests Software》
- [我收集的](../../3/1)

## 超级巨头曾经的结论

- 结对编程 + TDD 大约会增加 15-20% 的成本
- 但是提高70%的代码质量，减少反攻和上线时间

## 大佬说-1

- 自动化重构工具的效率极度影响开发效率

### 函数编程

- 在函数式风格里，说到底还是要考虑entity，value，不变性，reference这些，和OO也没有什么差别
- 函数式里，你定义一个函数，其实就是定义了一类函数
- 柯里化（英语：Currying）笔记 [《Java实战（第2版）》第 19 章 函数式编程的技巧](../../0/19)

### 小巨人项目

- 打基础用的，入职第一年需要看完的书 [点击查看共 28 本](../../../../../post/19/xjr.png)
- 消化就是做项目的时候，反思
- 不然项目做烂了，都不知道烂在哪
- 再做还是错
- 广度优先，先撑起来
- 核心技能要深挖，TDD
- 每天看书俩小时，TDD 8 小时

## 2022-04-12 🚀 2023-04-15

## 大佬说-2

- 我选了args，原因是它风格比较多样，并不一定非要写得特别oo或者fp，发挥的余地大
- api设计，需要一点想象力

## BDD

- BDD最开始就是个组织测试的办法
- 我司同事 Daivd North 在04年编的名字
- 第一个承载bdd思想的框架，jbehave
- 初创人是我以前项目上的to… TL
- 没有什么不同层次
- 就是写测试的角度不一样
- 不要描述具体功能
- 描述 feature 和 behave
- 比如不要写 should return 2 if 1 + 1
- 要写，be able to add positive number
- 然后二十年前，我们讨论来讨论去，最后就变成given-when-then了
- 用 given-when-then，描述业务，就是 BDD
- specification-by-example是不是BDD之后写的了？
  - 不是
  - specification by example 是 Gojko  Adzic
- **sbe 很好的**
- 我觉得sbe比bdd靠谱多了
- 我专门请过Gojko Adzic来北京，给我公司做过培训
- **因为 sbe 只解决一个问题，就是需求怎么分解** 而且做得很好
- **所谓 driven development，需要：需求、架构双分解** ⭐️⭐️⭐️⭐️⭐️
- bdd 的问题在于，很难驱动架构分解
- tdd 要求双分解
- 你拿什么分都行，只不过sbe很好用而已
- sbe 很多用法，最简单就是 story 分 ac
- 拆story也行
- example mapping
- bdd 是风格，bdd 框架承载了风格
- sbe 最好的工具，就是脑子
  - 这就跟，写诗有什么好工具嘛？
  - 写小说又什么好工具嘛？
  - 那不是word就行了，工具差异不大

## Golang ，我需要启动一个每 5s 执行一次的定时器，这个我如何验证呢？

- 分两步
  - 按时间间隔启动
  - 和间隔设置是5秒
- 测的时候 给间隔 100ms
- 然后 config 是 5
- 设计从 config 里拿配置
- 三个测试

## 为啥测试性，能提高代码质量

- 可测试的代码，都不会出写死
- 至少可以替换测试用功能和真的功能
- 永远都有俩选择，所以永远不会写死

## tw有没做技术洞察的方法论可以学习下的么

- 技术洞察很容易啊，过去15年所有重要文献读一遍
- 然后不明白的，自己试。很容易就洞察了
- 群友：有哪些重要文献？
  - 找一本最近出的书，连书带参考文献，看一遍
  - 参考文献的参考文献
  - 然后继续，直到都看完，不就知道了。肯定漏不掉
- 群友：没做过这块，就比较迷了，参考文献是个不错的方向，顺着引用倒是能挖出不少东西来
  - 你的出发点不重要，重要的都不会错过
  - 没做过也没关系
  - 随便从哪一本开始，然后开始看
  - 基本上愿意花功夫，一个月任何领域，能超过85%的人
  - 软件，特别是工程领域，没什么高深的

### mcafee 大哥的理论

- 有一年在美国，我们公司请来演讲的
- 他说，绝大部人会高估新技术的效果3倍
- 会低估已经存在技术的能力 3倍
- 所以新技术如果没有10x的优势
- 就会进入漫长的拉锯式变革，而不是马上
- 这里的问题在于，趋势是事后评估的
- 你在当下，把你认为牛X的方向 ➗ 3
- 你认为傻X的 x 3
- 再看看
- 企业2.0 Enterprise 2.0: How to Manage Social Technologies to Transform Your Organization
- 这位大哥是研究企业创新的

## 曾经有一段时间我们很迷恋cucumber

- 做过各种插件，word，excel，mingle（这个是我做的）
- 就是在业务工具里写验收，然后驱动自动化测试套去跑测试
- 后来发现其实没什么用，维护成本太高
- 为了解决这个问题，我们还专门做了一个工具，后来开源了，支持cucumber语法重构的ide插件
- 然后领悟了，我们执着于工具了，**应该是人与交互，建立人与人的信任，而不是人信任工具**
- cucumber所有这些，目的是 business readable
- 业务可读，不要求业务可写
- cucumber给你的东西不多
- 毕竟那个语法，写好了也不容易
- given when then，写成ui脚本的比比皆是
- 有那功夫，你直接画图不好嘛
- 直接画图就完了
- cucumber流行，就是因为大家觉得given when then好容易理解啊。然后都用，其实这要有用，你一开始就没啥问题
- 谁讲需求还不会，当怎么样就这么着了…
- 就好像sbe，很简单，什么需求，都说，你给我举个例子
- 然后你发现，有人开始穷举例子
- **sbe里，有人穷举例子，说明有概念缺失**
- **要提取抽象。这这一步，80%都差在这了**

## 不要问端到端

- 要问你想从测试获得什么
- 功能 + 定位
- 金字塔，越靠上，越能表示功能准确，但是不能定位
- 越往下，定位越准，但是无法还原业务
- 两个是不能替代的。无论是以全部功能替换定位测试，还是全部以小粒度去替换功能
- 但是有办法平衡。方法最简单就是，你这么想。如果我一个功能错了，多快我能找到哪错了
- 毕竟发现错，没用，你还得改对