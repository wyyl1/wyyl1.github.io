---
title: "21 ~ 24 笔记"
date: 2022-05-11T00:00:02+08:00
draft: false
tags: ["TDD","极客时间"]
categories: ["学习笔记"]
---

> [TDD 学习笔记 | 极客时间 | 徐昊·TDD 项目实战 70 讲](../dir)


## 21｜DI Container（9）：怎样重构测试代码？

- 通过 TDD 获得的测试，可以驱动我们的开发，但不代表获得的是一个良好的 Test Case 组合
- TDD 主要是为我们开发生产代码提供驱动力
- 天然得出的结果并不能认为是很好的 Test Case
- 所以需要对 Test Case 进行重构
  - 消除在构造 TDD 过程中留下的不一样的印记（架构选择、设计决策等）
  - 使 Test Case 能真实反应代码的意图
  - 按测试意图将零散的测试方法收集到一起（放入同一个 Nested 中或者单独的测试类中）
  - 同一个上下文中，测试粒度尽量保持一致
  - 清理没有用的测试


- 按测试意图将零散的测试方法收集到一起（放入同一个 Nested 中）
- 同一个上下文中，测试粒度最好是一样的

## 22｜DI Container（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？

测试变文档

- 从文档角度优化测试
- 使用 @Nested 将功能分组
- 测试天然不是文档，而是你实现过程的记录
- 对测试进行足够提取和刻意的组织后才能变成真正的文档

## 23｜DI Container（11）：如何对ContainerTest进行文档化改造？

- 经过梳理之后得到可执行的测试文档
- 通过抽取方法起到注释的作用

## 24｜DI Container（12）：如何增补功能？

```java
static abstract class TypeLiteral<T> {
    public ParameterizedType getType() {
        return (ParameterizedType)((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    }
}

ParameterizedType type = (ParameterizedType) new TypeLiteral<Provider<Component>>() {}.getType();

assertEquals(Provider.class, type.getRawType());
assertEquals(Component.class, type.getActualTypeArguments()[0]);
```