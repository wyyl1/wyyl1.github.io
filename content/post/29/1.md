---
title: "1.1.4 线程的状态"
date: 2024-04-13T08:00:01+08:00
draft: false
tags: ["线程的状态","Java"]
categories: ["学习笔记"]
---

[Java 并发编程的艺术第2版学习笔记](../dir)

> 原书：《Java 并发编程的艺术第2版》 | 作者：方腾飞 魏鹏 程晓明 | 2023 年 9 月 | 机械工业出版社

## Java 线程的状态

| 状态名称 | 说明 |
| --- | --- |
| NEW | 初始状态，线程被创建，但还没有调用 start() 方法 |
| RUNNABLE | 运行状态，Java 线程将操作系统中的**就绪**和**运行**两种状态笼统的称作**运行中** |
| BLOCKED | 阻塞状态，表示线程阻塞于锁 |
| WAITING | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（**通知**或**中断**） |
| TIMED_WAITING | 超时等待状态，该状态不同于 **WAITING**，它可以在指定的时间自行返回 |
| TERMINATED | 终止状态，表示当前线程已经执行完毕 |

![](../../../../../post/29/29-1-1.svg)

## 示例代码

ThreadState

```java
class ThreadState {

    public static void main(String[] args) {
        new Thread(new TimeWaiting(), "TimeWaitingThread").start();
        new Thread(new Waiting(), "WaitingThread").start();
        // 使用两个 Blocked 线程，一个获取锁成功，另一个被阻塞
        new Thread(new Blocked(), "BlockedThread-1").start();
        new Thread(new Blocked(), "BlockedThread-2").start();
    }

    // 该线程不断的睡眠
    static class TimeWaiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                sleep100Seconds();
            }
        }
    }

    // 该线程在 Waiting.class 实例上等待
    static class Waiting implements Runnable {
        @Override
        public void run() {
            while (true) {
                synchronized (Waiting.class) {
                    try {
                        Waiting.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    // 该线程在 Blocked.class 实例上加锁后，不会释放该锁
    static class Blocked implements Runnable {
        @Override
        public void run() {
            synchronized (Blocked.class) {
                sleep100Seconds();
            }
        }
    }

    private static void sleep100Seconds() {
        SleepUtils.second(100);
    }
}
```

SleepUtils

```java
import java.util.concurrent.TimeUnit;

class SleepUtils {
    static void second(long seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

运行 ThreadState 后，可以通过 `jps` 命令查看 Java 进程号，然后通过 `jstack 进程号` 查看线程状态。

使用 jps 命令查看当前运行的 Java 进程  
使用 jstack 命令查看线程堆栈信息，需要快速敲命令，不然 BlockedThread-1 就挂了

### AI 分析结果

- TimeWaitingThread (线程 14): 处于 TIMED_WAITING (sleeping) 状态。 这意味着该线程正在调用 sleep 方法并等待一段时间。
- WaitingThread (线程 15): 处于 WAITING (on object monitor) 状态。 这意味着该线程正在等待某个对象的监视器 (monitor) 被释放。
- BlockedThread-1 (16): 同样处于TIMED_WAITING状态，也是因为调用了Thread.sleep()。
- BlockedThread-2 (线程 17): 处于 TIMED_WAITING (sleeping) 状态。 这意味着该线程正在调用 sleep 方法并等待一段时间。

## 注意

- Java 将操作系统中的**就绪**和**运行**两种状态笼统的称作**运行状态**
- **阻塞状态**是线程阻塞进入 synchronized 关键字修饰的方法或代码块「获取锁」时的状态
- 但是阻塞在 java.concurrent 包中 Lock 接口的线程状态是 **WAITING**，而不是 **BLOCKED**，因为 java.concurrent 包中
  Lock 接口对于阻塞的实现使用了 **LockSupport** 类中的相关方法