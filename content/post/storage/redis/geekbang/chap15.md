---
title: "15 | 消息队列的考验：Redis有哪些解决方案？"
date: 2021-03-31T20:50:05+08:00
draft: false
tags: ["Redis"]
categories: ["存储"]
---

- [原文](https://time.geekbang.org/column/article/284291)

## 消息队列的消息存取需求

- 消息保序
- 重复消息处理
- 消息可靠性保证

## 基于 List 的消息队列解决方案

 List 本身就是按**先进先出**的顺序对数据进行存取

- LPUSH 命令
  - 把要发送的消息依次写入 List
- RPOP 命令
  - 从 List 的另一端按照消息的写入顺序，依次读取消息
- **BRPOP 命令也称为阻塞式读取**
  - 客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据
- BRPOPLPUSH 命令
  - 保证消息可靠性
  - 让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存
  - 如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理

## 基于 Streams 的消息队列解决方案

> Streams 是 Redis 5.0 **专门针对消息队列**场景设计的数据类型
> 和 List 相比，Streams 同样能够满足消息队列的三大需求。而且，它还支持消费组形式的消息读取

Streams 是 Redis 专门为消息队列设计的数据类型

- XADD：插入消息，保证有序，可以自动生成全局唯一 ID；
- XREAD：用于读取消息，可以按 ID 读取数据；
- XREADGROUP：按**消费组**形式读取消息；
  - 消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了
  - 目的是让组内的多个消费者共同分担读取消息
- XPENDING 和 XACK：
  - XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息
  - XACK 命令用于向消息队列确认消息处理已完成
  - 为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 **XACK** 命令通知 Streams“消息已经处理完成”。
  - 如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 **XPENDING** 命令查看已读取、但尚未确认处理完成的消息。

## 小结

- Streams 是 Redis 5.0 专门针对消息队列场景设计的数据类型，支持：有序、判重、可靠性。
- 一个 Redis 能搞定的消息队列，还要什么其他消息队列？
- Redis 是一个非常轻量级的键值数据库，部署一个 Redis 实例就是启动一个进程，部署 Redis 集群，也就是部署多个 Redis 实例
- Kafka、RabbitMQ 部署时，涉及额外的组件，例如 Kafka 的运行就需要再部署 ZooKeeper
- 相比 Redis 来说，Kafka 和 RabbitMQ 一般被认为是重量级的消息队列