---
title: "24 | 替换策略：缓存满了怎么办？"
date: 2021-04-02T18:50:05+08:00
draft: false
tags: ["Redis"]
categories: ["存储"]
---

[极客时间 | 《Redis核心技术与实战》学习笔记目录](../dir)

[原文](https://time.geekbang.org/column/article/294640)

## 设置多大的缓存容量合适？

- 建议把缓存容量设置为**总数据量的 15% 到 30%**，兼顾访问性能和内存空间开销。

## Redis 缓存有哪些淘汰策略？

![image](../../../../../post/storage/redis/geekbang/images/chap24-1.jpg)

- **默认**情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 **noeviction 策略**
  - 对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误
- **volatile-ttl** 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除
- **volatile-random** 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除
- **volatile-lru** 会使用 LRU 算法筛选设置了过期时间的键值对
- **volatile-lfu** 会使用 LFU 算法选择设置了过期时间的键值对
  - 在 LRU 算法的基础上，同时考虑了数据的访问时效性和数据的访问次数，可以看作是对淘汰策略的优化

相对于 volatile-ttl、volatile-random、volatile-lru、volatile-lfu 这四种策略淘汰的是设置了过期时间的数据，allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略的备选淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。它们筛选数据进行淘汰的规则是：

- **allkeys-random** 策略，从所有键值对中随机选择并删除数据
- **allkeys-lru** 策略，使用 LRU 算法在所有数据中进行筛选
- **allkeys-lfu** 策略，使用 LFU 算法在所有数据中进行筛选

LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会**带来额外的空间开销**。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。

在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。

Redis 提供了一个配置参数 **maxmemory-samples**，这个参数就是 Redis 选出的数据个数 N。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：

```cmd
CONFIG SET maxmemory-samples 100
```

## 三个使用建议

- **优先使用 allkeys-lru 策略**。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，强烈建议
- 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 **allkeys-random 策略**，随机选择淘汰的数据就行
- **如果你的业务中有置顶的需求**，比如置顶新闻、置顶视频，那么，可以使用 **volatile-lru 策略**，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选

## 如何处理被淘汰的数据？