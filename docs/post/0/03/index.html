<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>第 3 章 Lambda 表达式 -</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="wyyl1"><script src=/js/baidu_tongji.js></script><meta name=description content="笔记来源：《Java实战（第2版）》ISBN:978-7-115-52148-4 作者：拉乌尔·加布里埃尔·乌尔玛,马里奥·富斯科,艾伦·米克"><meta name=keywords content="wyyl1,万有引力一,Hugo"><meta name=generator content="Hugo 0.82.0 with theme even"><link rel=canonical href=https://wyyl1.github.io/post/0/03/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.39a3e01cac9473be1356f3572fcfe34b2e363efabad244a99a40f28a812c837e.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="第 3 章 Lambda 表达式"><meta property="og:description" content="笔记来源：《Java实战（第2版）》ISBN:978-7-115-52148-4 作者：拉乌尔·加布里埃尔·乌尔玛,马里奥·富斯科,艾伦·米克"><meta property="og:type" content="article"><meta property="og:url" content="https://wyyl1.github.io/post/0/03/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-04-15T00:00:01+08:00"><meta property="article:modified_time" content="2021-04-15T00:00:01+08:00"><meta itemprop=name content="第 3 章 Lambda 表达式"><meta itemprop=description content="笔记来源：《Java实战（第2版）》ISBN:978-7-115-52148-4 作者：拉乌尔·加布里埃尔·乌尔玛,马里奥·富斯科,艾伦·米克"><meta itemprop=datePublished content="2021-04-15T00:00:01+08:00"><meta itemprop=dateModified content="2021-04-15T00:00:01+08:00"><meta itemprop=wordCount content="1498"><meta itemprop=keywords content="Java,Java实战,Lambda,"><meta name=twitter:card content="summary"><meta name=twitter:title content="第 3 章 Lambda 表达式"><meta name=twitter:description content="笔记来源：《Java实战（第2版）》ISBN:978-7-115-52148-4 作者：拉乌尔·加布里埃尔·乌尔玛,马里奥·富斯科,艾伦·米克"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>wyyl1</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>首页</li></a><a href=/post/><li class=mobile-menu-item>文章</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/post/dir><li class=mobile-menu-item>目录</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>wyyl1</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>首页</a></li><li class=menu-item><a class=menu-item-link href=/post/>文章</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/post/dir>目录</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>第 3 章 Lambda 表达式</h1><div class=post-meta><span class=post-time>2021-04-15</span><div class=post-category><a href=/categories/java/>Java</a>
<a href=/categories/java%E5%AE%9E%E6%88%98%E7%AC%AC2%E7%89%88/>Java实战（第2版）</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#方法引用->方法引用 ::</a></li><li><a href=#predicate>Predicate</a></li><li><a href=#行为参数化>行为参数化</a></li><li><a href=#lambda>Lambda</a><ul><li><a href=#表-3-1-lambda-示例>表 3-1 Lambda 示例</a></li></ul></li><li><a href=#函数式接口>函数式接口</a><ul><li><a href=#functionalinterface>@FunctionalInterface</a></li><li><a href=#341-predicate>3.4.1 Predicate</a></li><li><a href=#342-consumer>3.4.2 Consumer</a></li><li><a href=#343-function>3.4.3 Function</a></li><li><a href=#基本类型函数接口>基本类型函数接口</a></li><li><a href=#36-方法引用>3.6 方法引用</a></li><li><a href=#38-复合-lambda-表达式的有用方法>3.8 复合 Lambda 表达式的有用方法</a></li><li><a href=#39-数学中的类似思想>3.9 数学中的类似思想</a></li><li><a href=#310-小结>3.10 小结</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><blockquote><p>笔记来源：《Java实战（第2版）》ISBN:978-7-115-52148-4 作者：拉乌尔·加布里埃尔·乌尔玛,马里奥·富斯科,艾伦·米克罗夫特.</p></blockquote><p><a href=../dir target=_blank>Java实战（第2版）学习笔记目录</a></p><h2 id=方法引用->方法引用 ::</h2><ul><li>创建方法引用（File::isHidden）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>File</span><span class=o>[]</span> <span class=n>hiddenFiles</span> <span class=o>=</span> <span class=k>new</span> <span class=n>File</span><span class=o>(</span><span class=s>&#34;.&#34;</span><span class=o>).</span><span class=na>listFiles</span><span class=o>(</span><span class=n>File</span><span class=o>::</span><span class=n>isHidden</span><span class=o>);</span>
</code></pre></td></tr></table></div></div><h2 id=predicate>Predicate</h2><ul><li>谓词：在数学上常常用来代表类似于函数的东西，它接受一个参数值，并返回 <strong>true</strong> 或 <strong>false</strong></li><li>优点：代码更干净、更清晰</li><li>复杂的条件可以使用策略模式</li><li>更好的实现 DRY(Don&rsquo;t Repeat Yourself)</li></ul><h2 id=行为参数化>行为参数化</h2><ul><li>通俗解释：让方法接受多种行为（策略）作为参数，并在内部使用，来完成不同的行为</li><li>优点：让代码更能适应需求的变化</li></ul><h2 id=lambda>Lambda</h2><ul><li>可以理解为一种简洁的可传递匿名函数<ul><li>没有名称</li><li>有参数列表、函数主体、返回类型</li><li>允许有一个可以抛出的异常列表</li><li>Lambda 表达式可以作为参数传递给方法或存储在变量中</li><li>Lambda 没有 return 语句，因为已经隐含了 return</li><li>可以返回 void <code>() -> {}</code></li><li>起源于学术界开发出的一套用来描述计算的λ演算法</li></ul></li></ul><h3 id=表-3-1-lambda-示例>表 3-1 Lambda 示例</h3><table><thead><tr><th>使用案例</th><th>Lambda 示例</th></tr></thead><tbody><tr><td>布尔表达式</td><td>(List<string> list) -> list.isEmpty()</td></tr><tr><td>创建对象</td><td>() -> new Apple(10)</td></tr><tr><td>消费一个对象</td><td>(Apple a) -> { System.out.println(a.getWeight()); }</td></tr><tr><td>从一个对象中选择/抽取</td><td>(String s) -> s.length()</td></tr><tr><td>组合两个值</td><td>(int a, int b) -> a * b</td></tr><tr><td>比较两个对象</td><td>(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())</td></tr><tr><td>返回 String 作为表达式</td><td>() -> &ldquo;Hi&rdquo;</td></tr><tr><td>返回 String（利用显示返回语句）</td><td>() -> {return &ldquo;Hi&rdquo;;}</td></tr></tbody></table><h2 id=函数式接口>函数式接口</h2><ul><li>只定义一个抽象方法的接口</li></ul><h3 id=functionalinterface>@FunctionalInterface</h3><h3 id=341-predicate>3.4.1 Predicate</h3><ul><li>java.util.function.Predicate</li><li>boolean test(T t);<ul><li>t : the function argument</li><li>r : the function result</li></ul></li></ul><h3 id=342-consumer>3.4.2 Consumer</h3><ul><li>消费者</li><li>void accept(T t);</li></ul><h3 id=343-function>3.4.3 Function</h3><ul><li>R apply(T t);</li><li>接受泛型 T 的参数，返回泛型 R 的对象</li></ul><h3 id=基本类型函数接口>基本类型函数接口</h3><ul><li>装箱后的值本质上就是把基本类型包裹起来，并保存在堆里</li><li>因此，装箱后的值需要更多的内存</li><li>并且需要额外的内存搜索来获取被包裹的基本值</li></ul><p>使用类似下列函数式接口可以避免自动装箱操作</p><ul><li>IntPredicate</li><li>LongConsumer</li><li>DoubleFunction</li></ul><p>更多接口详见：表 3-2 Java 8 中的常用函数式接口
表 3-3 Lambda 及函数式接口的例子</p><table><thead><tr><th>使用案例</th><th>Lambda 的例子</th><th>对应的函数式接口</th></tr></thead><tbody><tr><td>布尔表达式</td><td>(List<string> list) -> list.isEmpty()</td><td>Predicate&lt;List<string>></td></tr><tr><td>创建对象</td><td>() -> new Apple(10)</td><td>Supplier<apple></td></tr><tr><td>消费一个对象</td><td>(Apple a) -> System.out.println(a.getWeight)</td><td>Consumer<apple></td></tr><tr><td>从一个对象中提取</td><td>(String s) -> s.length()</td><td>Function&lt;String, Integer><br>ToIntFunction<string></td></tr><tr><td>合并两个值</td><td>(int a, int b) -> a * b</td><td>IntBinaryOperator</td></tr><tr><td>比较两个对象</td><td>(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())</td><td>Comparator<apple><br>BiFunction&lt;Apple, Apple, Integer><br>ToIntBiFunction&lt;Apple, Apple, Apple></td></tr></tbody></table><h3 id=36-方法引用>3.6 方法引用</h3><ul><li>方法引用主要有三类<ul><li>指向静态方法的方法引用</li><li>指向任意类型示例方法的方法引用</li><li>指向现存对象或表达式实例方法的方法引用</li></ul></li></ul><p>图 3-5 改编</p><table><thead><tr><th>Lambda</th><th>方法引用</th><th>备注</th></tr></thead><tbody><tr><td>(args) -> ClassName.staticMethod(args)</td><td>ClassName::staticMethod</td><td></td></tr><tr><td>(arg0, rest) -> arg0.instanceMethod(rest)</td><td>ClassName::instanceMethod</td><td>arg0 是 ClassName 类型的</td></tr><tr><td>(args) -> expr.instanceMethod(args)</td><td>expr::instanceMethod</td><td></td></tr></tbody></table><p>测验3.6：方法引用</p><table><thead><tr><th>Lambda</th><th>方法引用</th></tr></thead><tbody><tr><td>ToIntFunction<string> stringToInt = (String s) -> Integer.parseInt(s);</td><td>ToIntFunction<string> stringToInt = Integer:parseInt;</td></tr><tr><td>BiPredicate&lt;List<string>, String> contains = (list, element) -> list.contains(element);</td><td>BiPredicate&lt;List<string>, String> contains = List::contains;</td></tr><tr><td>Predicate<string> startsWithNumber = (String string) -> this.startWithNumber(string);</td><td>Predicate<string> startsWithNumber = this::startsWithNumber</td></tr></tbody></table><h4 id=362-构造函数引用>3.6.2 构造函数引用</h4><h3 id=38-复合-lambda-表达式的有用方法>3.8 复合 Lambda 表达式的有用方法</h3><h4 id=382-谓词复合>3.8.2 谓词复合</h4><p>谓词接口包括三个方法</p><ul><li>negate<ul><li>返回 Predicate 的非，例如苹果不是红的 Predicate<apple> notRedApple = redApple.negate();</li></ul></li><li>and</li><li>or</li></ul><h4 id=383-函数复合>3.8.3 函数复合</h4><h5 id=andthen-方法会返回一个函数>andThen 方法会返回一个函数</h5><ul><li>先对输入，执行一个给定函数</li><li>在对输出，执行另一个函数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>g</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>*</span> <span class=n>2</span><span class=o>;</span>
        <span class=c1>// 数学上写作：g(f(x))
</span><span class=c1></span>        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>h</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=na>andThen</span><span class=o>(</span><span class=n>g</span><span class=o>);</span>
        <span class=c1>// 结果是 4
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
</code></pre></td></tr></table></div></div><h5 id=compose-方法>compose 方法</h5><ul><li>先对输入执行 compose 后的函数</li><li>再将之前的结果作为输入，执行 compose 前的函数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>g</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span> <span class=o>*</span> <span class=n>2</span><span class=o>;</span>
        <span class=c1>// 数学上写作：f(g(x))
</span><span class=c1></span>        <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>h</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=na>compose</span><span class=o>(</span><span class=n>g</span><span class=o>);</span>
        <span class=c1>// 结果是 3
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>
</code></pre></td></tr></table></div></div><p>图3-6说明了andThen和compose之间的区别</p><h5 id=作用可以组成强大的流水线对新手来说并不友好因为无法推测出正确的结果>作用：可以组成强大的流水线（对新手来说并不友好，因为无法推测出正确的结果）</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=nf>addHeader</span><span class=o>(</span><span class=n>String</span> <span class=n>text</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34;Header: &#34;</span> <span class=o>+</span> <span class=n>text</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=nf>addFooter</span><span class=o>(</span><span class=n>String</span> <span class=n>text</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34; Footer &#34;</span> <span class=o>+</span> <span class=n>text</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=nf>checkSpelling</span><span class=o>(</span><span class=n>String</span> <span class=n>text</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>text</span><span class=o>.</span><span class=na>replaceAll</span><span class=o>(</span><span class=s>&#34;labda&#34;</span><span class=o>,</span> <span class=s>&#34;lambda&#34;</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>assemblyLine1</span><span class=o>(){</span>
        <span class=n>String</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;流水线1&#34;</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>addHeader</span> <span class=o>=</span> <span class=n>Chap03Letter</span><span class=o>::</span><span class=n>addHeader</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>transformationPipeline</span> <span class=o>=</span> <span class=n>addHeader</span>
                <span class=o>.</span><span class=na>andThen</span><span class=o>(</span><span class=n>Chap03Letter</span><span class=o>::</span><span class=n>checkSpelling</span><span class=o>)</span>
                <span class=o>.</span><span class=na>andThen</span><span class=o>(</span><span class=n>Chap03Letter</span><span class=o>::</span><span class=n>addFooter</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>transformationPipeline</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>text</span><span class=o>));</span>
        <span class=c1>// 输出：Footer Header: 流水线1
</span><span class=c1></span>    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>assemblyLine2</span><span class=o>(){</span>
        <span class=n>String</span> <span class=n>text</span> <span class=o>=</span> <span class=s>&#34;流水线2&#34;</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>addHeader</span> <span class=o>=</span> <span class=n>Chap03Letter</span><span class=o>::</span><span class=n>addHeader</span><span class=o>;</span>
        <span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>transformationPipeline</span> <span class=o>=</span> <span class=n>addHeader</span>
                <span class=o>.</span><span class=na>compose</span><span class=o>(</span><span class=n>Chap03Letter</span><span class=o>::</span><span class=n>checkSpelling</span><span class=o>)</span>
                <span class=o>.</span><span class=na>compose</span><span class=o>(</span><span class=n>Chap03Letter</span><span class=o>::</span><span class=n>addFooter</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>transformationPipeline</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>text</span><span class=o>));</span>
        <span class=c1>// 输出：Header:  Footer 流水线2
</span><span class=c1></span>    <span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=39-数学中的类似思想>3.9 数学中的类似思想</h3><p>f(x) = x + 10</p><h3 id=310-小结>3.10 小结</h3><ul><li>Lambda 表达式可以理解为一种匿名函数<ul><li>没有名称</li><li>有参数列表、函数主体、返回类型</li><li>可能还有一个可以抛出的异常列表</li></ul></li><li>Lambda 表达式让你可以简洁地传递代码</li><li><strong>函数式接口</strong>就是仅仅声明了一个抽象方法的接口</li><li>只有在接受函数式接口的地方才可以使用 Lambda 表达式</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>wyyl1</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-04-15</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/java/>Java</a>
<a href=/tags/java%E5%AE%9E%E6%88%98/>Java实战</a>
<a href=/tags/lambda/>Lambda</a></div><nav class=post-nav><a class=prev href=/post/0/04/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">第 4 章 引入流</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/0/dir/><span class="next-text nav-default">Java实战（第2版）学习笔记</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://github.com/wyyl1 class="iconfont icon-github" title=github></a><a href=https://space.bilibili.com/349506199 class="iconfont icon-bilibili" title=bilibili></a><a href=https://wyyl1.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=division>|</span>
<span class=theme-info><a class=hexo-link href=https://beian.miit.gov.cn>浙ICP备16025224号-2</a></span>
<span class=copyright-year>&copy;
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>wyyl1</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script src=/js/baidu_tongji.js></script></body></html>